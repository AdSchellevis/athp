Porting bits from ath10k:

Based on linux-next commit id 76d164f582150fd0259ec0fcbc485470bcd8033e .

* pci/pcie - includes a lot of SoC futzing to do things like cold/warm reset, etc
* legacy interrupts require magic, check pci.c
* copy engine pipe config
* copy engine basics
* bmi
* .. at this point we should be able to load in firmware

Then:

* finish off copy engine bits
* htt
* wmi
* whatever missing pieces for tx/rx dma at this point (should've been done above, but..)
* send/recieve commands to firmware
* data!

Notes:

* ath10k has more than Peregrine 2.0 (QCA988x) support
* it supports newer firmware, but chances are peregrine support is only 10.1 / 10.2
* .. so don't cheat by hard-coding 10.1 or 10.2 APIs; we have to do this somewhat
  clean early on.

Bring-up order; more detail

* (done) probe/attach
* (done) pci bits (chip)
* (done) sleep/wake
* (done) ce bits
* (done) busdma bits for mbuf, etc
* (done) pipe bits, stubbed out
* (done) wire up interrupts, enable/disable interrupts, even if it's legacy interrupts
* (done) .. and add per-pipe interrupt task, schedule it appropriately
* (done) wire up the global rx retry taskqueue as a taskqueue_timer
* (done) .. and ensure the above gets cleaned up during shutdown

Then look at what calls init_pipes() - cold/warm reset, chip reset, etc.
And hif_powerup().  The target is to complete hif_powerup / hif_powerdown.

* (done) then, just port / stub appropriately the hif layer, only implementing the
  pieces we need and printf() stubbing the rest.

The mac80211 setup sequence ends up calling ath10k_core_probe_fw() which
brings things up and then tears them down again so the ath10k_start() routine
can bring it up again.  It's .. silly, but that's what ath10k does.
ath10k_core_probe_fw() is a good finishing point to verify that the basic bits
are working - I don't think I need interrupts working (yet); I don't think
I need WMI/HTT working.

However, to tear the state down afterwards (ie, put the core into suspend mode)
I need to have WMI working as the target suspend call is a WMI message.
So stub that part of the setup out and just verify that the core can be brought
up and stopped.

Ie:

* (done) init pipes, incl. replenishing rx mbufs, etc
* (done) init config
* (done) wake target cpu

This requires pci_diag_read32(), pci_diag_write32(), pci_diag_writemem()
to work.  And /these/ require the CE bits to work, DMA map/unmap to work, etc.
It doesn't require interrupts; it's polled; so it should be pretty fun to bringup.

I /think/ TX alignment is 4 bytes, not 8 bytes.  Hm.

At this point the diag read/write works, the CE bits work w/ polling, and
basic locking is working.  Hopefully the target wakes up and accepts a pipe
config, and we can make a start on porting the rest of the BMI code for
firmware injection and start stubbing out the HIF layer for implementing.
The only bits of HIF layer we need are power_on, stop, power_off and the BMI
HIF wait for message routine.

net80211 bringup:

* (done) mac.c - has the commands to send, the tx/rx path into mac80211, and the
  command path
* (done) thermal.c - thermal control
* p2p.c - p2p support
* debug*.c - debugfs support (yes, for debugging)

rough order for net80211 bringup:

* (done) add ath10k/mac.c into if_athp_mac.c, and stub out almost everything
* make peer create/destroy work
* (done) make vif create/destroy work
* (done) leave the chanctx bits stubbed out, but at least eyeball them to see
  how they're supposed to work (eg when they're doing channel switches, etc)
* (done) write scan stubs so we don't change channel for scans
* (done) stub out the net80211 management frame sending for now, leave it up to the
  driver (so scans are done by the driver!) - same as if_rsu.c, I hope!
* (done) program in a regulatory domain into the firmware, so it doesn't panic!
* (done) add in initial scan support, see if we can get scan results!

Then checkpoint, and fix up the dirty pieces before we continue.

Things to finish doing:

* (done) dma coherent API - remove it entirely; use the freebsd calls
  (otherwise device_t versus struct device (linux) gets unhappy;
  the linux layer really expects struct device)
* (done) convert everything to freebsd list iteration
* (done) convert everything to freebsd tasks, task_timeouts, callout as appropriate
  (the linux lock model and callout/tasklet model doens't seem to be implemented
  completely 'right' with what freebsd needs.)

MSI:

* figure out all of the MSI bits that I missed!
* (done) add single MSI support
* do MSI-X support

802.11 fragmentation:

* TODO: need to teach net80211 about never doing 802.11 fragmentation, as the
  firmware does it for us.  Otherwise firmware will transmit the frames with
  the fragment bit cleared (which it does), leading to garbage.
* TODO: if in raw mode then net80211 does fragmentation; else don't and let
  the firmware do it.
* TODO: teach the athp_transmit() API about fragments and at least warn/print
  about it for now!

===

* Re-revisit all of the regulatory stuff - hardcoded txpower lists are bad.
  Hard-coded EEPROM regulatory code is bad.  Etc, etc.

* (done) Add busdma ops to all the places where we do descdma operations - especiall
  ath10k_htt_tx() and the completion path (wherever txbuf_paddr is referenced -
  find where it first checks the txbuf and go from there.)

* (done) Sending frames require a peer.  If there's no peer, then we can't actually
  transmit it - it'll just get stuck in the transmit queue.  Figure this out?

* (done) Tidy up tx power handling - when creating an interface, set the arvif txpower
  to a suitable value.  When scanning, etc, also do the same.

* (done) Extend net80211 rx_stats struct to include MAC timestamp, PHY timestamp,
  RX duration, RX phy/rate, etc, etc.  Then, teach the htt_r routines
  (eg things referenced in htt_rx_h_ppdu())

* (done) AMSDU more flag too; the upper layer should be told about AMSDU-more so
  it knows not to do some checks (eg all decaped AMSDU frames will
  share the same faked seqno, crypto, IV, etc.)

* (done) RX checksum offloading - htt_rx_h_csum_offload()

* (done) Revisit the timeouts (ath10k_wait, ath10k_compl) and anywhere that sleep/wakeup
  times are calculated (grep for ticks, time_after, etc).
  The sleep time is 1ms per loop check, which is too long?

* (done) Fix up the bitops/idr code to have its own namespace for everything so it
  doesn't trip up the linux compat layer symbols.

* (done) the regulatory code programs in the regdomain in a regdomain callback handler.
  If we don't call that WMI routine then things fail badly and the firmware
  panics.

  (done) Go find ath10k_regd_update() and ensure we call it as part of dev/vif up or
  firmware will panic upon scan!


Panics / locking issues that need addressing
============================================

* There's a problem with the frame cleanup path:
  - ath10k_halt()
  - holds CONF lock whilst it does its shutdown parts
  - goes through htt_tx free
  - frees the TX buffers
  - one of them has a node reference
  - node reference is the last node reference
  - that triggers a node delete
  - that re-enters the driver and calls athp_peer_free()
  - athp_peer_free() grabs the lock and goes to mtx_sleep()
  - .. and it's sleeping on a recursed lock.

* peer deletion sleeps on a net80211 lock in some instances - fix!
